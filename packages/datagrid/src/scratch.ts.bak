

  // /**
  //  * Get the current client rect for the data grid viewport.
  //  *
  //  * @returns The current client rect for the viewport.
  //  *
  //  * #### Notes
  //  * This rect is useful for grid behaviors when converting from
  //  * client mouse position to local viewport coordinates.
  //  */
  // viewportClientRect(): ClientRect {
  //   return this._viewport.node.getBoundingClientRect();
  // }

  // /**
  //  * Get the total number of sections in a section group.
  //  *
  //  * @param group - The section group of interest.
  //  *
  //  * @returns The total number of sections in the group.
  //  *
  //  * #### Notes
  //  * This value is equivalent to that provided by the data model.
  //  */
  // sectionCount(group: DataGrid.SectionGroup): number {
  //   return this._getSectionList(group).count;
  // }

  // /**
  //  * Get the total virtual length of a section group.
  //  *
  //  * @param group - The section group of interest.
  //  *
  //  * @returns The total virtual length of the section group.
  //  *
  //  * #### Notes
  //  * Header visibility has no effect on this value.
  //  */
  // sectionLength(group: DataGrid.SectionGroup): number {
  //   return this._getSectionList(group).length;
  // }

  // /**
  //  * Get the index of the section at an unscrolled offset.
  //  *
  //  * @param group - The name of the section group of interest.
  //  *
  //  * @param offset - The unscrolled offset of interest.
  //  *
  //  * @returns The index of the section, or `-1` if `offset` is invalid.
  //  */
  // sectionIndex(group: DataGrid.SectionGroup, offset: number): number {
  //   return this._getSectionList(group).indexOf(offset);
  // }

  // /**
  //  * Get the unscrolled offset of a section in the data grid.
  //  *
  //  * @param group - The name of the section group of interest.
  //  *
  //  * @param index - The index of the section of interest.
  //  *
  //  * @return The offset of the section, or `-1` if `index` is invalid.
  //  */
  // sectionOffset(group: DataGrid.SectionGroup, index: number): number {
  //   return this._getSectionList(group).offsetOf(index);
  // }

  // *
  //  * Get the size of a section in the data grid.
  //  *
  //  * @param group - The name of the section group of interest.
  //  *
  //  * @param index - The index of the section of interest.
  //  *
  //  * @return The size of the section, or `-1` if `index` is invalid.

  // sectionSize(group: DataGrid.SectionGroup, index: number): number {
  //   return this._getSectionList(group).sizeOf(index);
  // }

  // /**
  //  * Resize a section in the data grid.
  //  *
  //  * @param group - The name of the section group of interest.
  //  *
  //  * @param index - The index of the section of interest.
  //  *
  //  * @param size - The new size for the section.
  //  *
  //  * #### Notes
  //  * This is a no-op if `index` is invalid.
  //  */
  // resizeSection(group: DataGrid.SectionGroup, index: number, size: number): void {
  //   this._resizeSection(this._getSectionList(group), index, size);
  // }

  // /**
  //  * Get the base size of a section group.
  //  *
  //  * @param group - The section group of interest.
  //  *
  //  * @returns The base size of the specified section group.
  //  */
  // sectionBaseSize(group: DataGrid.SectionGroup): number {
  //   return this._getSectionList(group).baseSize;
  // }

  // /**
  //  * Set the base size of a section group.
  //  *
  //  * @param group - The section group of interest.
  //  */
  // setSectionBaseSize(group: DataGrid.SectionGroup, size: number): void {
  //   // Normalize the size.
  //   size = Math.max(0, Math.floor(size));

  //   // Fetch the section list.
  //   let list = this._getSectionList(group);

  //   // Bail early if the size does not change.
  //   if (list.baseSize === size) {
  //     return;
  //   }

  //   // Update the list base size.
  //   list.baseSize = size;

  //   // Sync the viewport
  //   this._syncViewport();
  // }

  // /**
  //  * Reset sections in the data grid to their base size.
  //  *
  //  * @param group - The name of the section group of interest.
  //  */
  // resetSections(group: DataGrid.SectionGroup): void {
  //   // Reset the section list to the base size.
  //   this._getSectionList(group).reset();

  //   // Sync the viewport.
  //   this._syncViewport();
  // }



  /**
   * A type alias for the data grid section groups.
   */
  export
  type SectionGroup = 'row' | 'column' | 'row-header' | 'column-header';

  /**
   * Get the section list for the specified section group.
   */
  private _getSectionList(area: DataGrid.SectionGroup): SectionList {
    let list: SectionList;
    switch (area) {
    case 'row':
      list = this._rowSections;
      break;
    case 'column':
      list = this._columnSections;
      break;
    case 'row-header':
      list = this._rowHeaderSections;
      break;
    case 'column-header':
      list = this._columnHeaderSections;
      break;
    default:
      throw 'unreachable';
    }
    return list;
  }


  /**
   * Resize a section in the given section list.
   *
   * #### Notes
   * This will update the scroll bars and repaint as needed.
   */
  private _resizeSection(list: SectionList, index: number, size: number): void {
    // Bail early if the index is out of range.
    if (index < 0 || index >= list.count) {
      return;
    }

    // Look up the old size of the section.
    let oldSize = list.sizeOf(index);

    // Normalize the new size of the section.
    let newSize = Math.max(0, Math.floor(size));

    // Bail early if the size does not change.
    if (oldSize === newSize) {
      return;
    }

    // Resize the section in the list.
    list.resize(index, newSize);

    // Get the current size of the viewport.
    let vpWidth = this._viewportWidth;
    let vpHeight = this._viewportHeight;

    // If there is nothing to paint, sync the scroll state.
    if (!this._viewport.isVisible || vpWidth === 0 || vpHeight === 0) {
      this._syncScrollState();
      return;
    }

    // If a paint is already pending, sync the viewport.
    if (this._paintPending) {
      this._syncViewport();
      return;
    }

    // Compute the size delta.
    let delta = newSize - oldSize;

    // Paint the relevant dirty regions.
    switch (list) {
    case this._rowSections:
    {
      // Look up the column header height.
      let hh = this.headerHeight;

      // Compute the viewport offset of the section.
      let offset = list.offsetOf(index) + hh - this._scrollY;

      // Bail early if there is nothing to paint.
      if (hh >= vpHeight || offset > vpHeight) {
        break;
      }

      // Update the scroll position if the section is not visible.
      if (offset + oldSize <= hh) {
        this._scrollY += delta;
        break;
      }

      // Compute the paint origin of the section.
      let pos = Math.max(hh, offset);

      // Paint from the section onward if it spans the viewport.
      if (offset + oldSize >= vpHeight || offset + newSize >= vpHeight) {
        this._paint(0, pos, vpWidth, vpHeight - pos);
        break;
      }

      // Compute the X blit dimensions.
      let sx = 0;
      let sw = vpWidth;
      let dx = 0;

      // Compute the Y blit dimensions.
      let sy: number;
      let sh: number;
      let dy: number;
      if (offset + newSize <= hh) {
        sy = hh - delta;
        sh = vpHeight - sy;
        dy = hh;
      } else {
        sy = offset + oldSize;
        sh = vpHeight - sy;
        dy = sy + delta;
      }

      // Blit the valid content to the destination.
      this._blit(this._canvas, sx, sy, sw, sh, dx, dy);

      // Repaint the section if needed.
      if (newSize > 0 && offset + newSize > hh) {
        this._paint(0, pos, vpWidth, offset + newSize - pos);
      }

      // Paint the trailing space if needed.
      if (delta < 0) {
        this._paint(0, vpHeight + delta, vpWidth, -delta);
      }

      // Done.
      break;
    }
    case this._columnSections:
    {
      // Look up the row header width.
      let hw = this.headerWidth;

      // Compute the viewport offset of the section.
      let offset = list.offsetOf(index) + hw - this._scrollX;

      // Bail early if there is nothing to paint.
      if (hw >= vpWidth || offset > vpWidth) {
        break;
      }

      // Update the scroll position if the section is not visible.
      if (offset + oldSize <= hw) {
        this._scrollX += delta;
        break;
      }

      // Compute the paint origin of the section.
      let pos = Math.max(hw, offset);

      // Paint from the section onward if it spans the viewport.
      if (offset + oldSize >= vpWidth || offset + newSize >= vpWidth) {
        this._paint(pos, 0, vpWidth - pos, vpHeight);
        break;
      }

      // Compute the Y blit dimensions.
      let sy = 0;
      let sh = vpHeight;
      let dy = 0;

      // Compute the X blit dimensions.
      let sx: number;
      let sw: number;
      let dx: number;
      if (offset + newSize <= hw) {
        sx = hw - delta;
        sw = vpWidth - sx;
        dx = hw;
      } else {
        sx = offset + oldSize;
        sw = vpWidth - sx;
        dx = sx + delta;
      }

      // Blit the valid content to the destination.
      this._blit(this._canvas, sx, sy, sw, sh, dx, dy);

      // Repaint the section if needed.
      if (newSize > 0 && offset + newSize > hw) {
        this._paint(pos, 0, offset + newSize - pos, vpHeight);
      }

      // Paint the trailing space if needed.
      if (delta < 0) {
        this._paint(vpWidth + delta, 0, -delta, vpHeight);
      }

      // Done.
      break;
    }
    case this._rowHeaderSections:
    {
      // Look up the offset of the section.
      let offset = list.offsetOf(index);

      // Bail early if the section is fully outside the viewport.
      if (offset >= vpWidth) {
        break;
      }

      // Paint the entire tail if the section spans the viewport.
      if (offset + oldSize >= vpWidth || offset + newSize >= vpWidth) {
        this._paint(offset, 0, vpWidth - offset, vpHeight);
        break;
      }

      // Compute the blit content dimensions.
      let sx = offset + oldSize;
      let sy = 0;
      let sw = vpWidth - sx;
      let sh = vpHeight;
      let dx = sx + delta;
      let dy = 0;

      // Blit the valid contents to the destination.
      this._blit(this._canvas, sx, sy, sw, sh, dx, dy);

      // Repaint the header section if needed.
      if (newSize > 0) {
        this._paint(offset, 0, newSize, vpHeight);
      }

      // Paint the trailing space if needed.
      if (delta < 0) {
        this._paint(vpWidth + delta, 0, -delta, vpHeight);
      }

      // Done
      break;
    }
    case this._columnHeaderSections:
    {
      // Look up the offset of the section.
      let offset = list.offsetOf(index);

      // Bail early if the section is fully outside the viewport.
      if (offset >= vpHeight) {
        break;
      }

      // Paint the entire tail if the section spans the viewport.
      if (offset + oldSize >= vpHeight || offset + newSize >= vpHeight) {
        this._paint(0, offset, vpWidth, vpHeight - offset);
        break;
      }

      // Compute the blit content dimensions.
      let sx = 0;
      let sy = offset + oldSize;
      let sw = vpWidth;
      let sh = vpHeight - sy;
      let dx = 0;
      let dy = sy + delta;

      // Blit the valid contents to the destination.
      this._blit(this._canvas, sx, sy, sw, sh, dx, dy);

      // Repaint the header section if needed.
      if (newSize > 0) {
        this._paint(0, offset, vpWidth, newSize);
      }

      // Paint the trailing space if needed.
      if (delta < 0) {
        this._paint(0, vpHeight + delta, vpWidth, -delta);
      }

      // Done
      break;
    }
    default:
      throw 'unreachable';
    }

    // Sync the scroll state after painting.
    this._syncScrollState();
  }
