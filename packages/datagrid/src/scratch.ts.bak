

  // /**
  //  * The scroll X offset of the viewport.
  //  */
  // get scrollX(): number {
  //   return this._hScrollBar.value;
  // }

  // /**
  //  * The scroll Y offset of the viewport.
  //  */
  // get scrollY(): number {
  //   return this._vScrollBar.value;
  // }

  // /**
  //  * The maximum scroll X position for the current grid dimensions.
  //  *
  //  * #### Notes
  //  * This value is `1px` less than the theoretical maximum to allow the
  //  * the right-most grid line to be clipped when the vertical scroll bar
  //  * is visible.
  //  */
  // get maxScrollX(): number {
  //   return Math.max(0, this.bodyWidth - this.pageWidth - 1);
  // }

  // /**
  //  * The maximum scroll Y position for the current grid dimensions.
  //  *
  //  * #### Notes
  //  * This value is `1px` less than the theoretical maximum to allow the
  //  * the bottom-most grid line to be clipped when the horizontal scroll
  //  * bar is visible.
  //  */
  // get maxScrollY(): number {
  //   return Math.max(0, this.bodyHeight - this.pageHeight - 1);
  // }

  // /**
  //  * The virtual width of the grid body.
  //  *
  //  * #### Notes
  //  * This value does not include the width of the row headers.
  //  */
  // get bodyWidth(): number {
  //   return this._columnSections.length;
  // }

  // /**
  //  * The virtual height of the grid body.
  //  *
  //  * #### Notes
  //  * This value does not include the height of the column headers.
  //  */
  // get bodyHeight(): number {
  //   return this._rowSections.length;
  // }

  // /**
  //  * The virtual width of the row headers.
  //  *
  //  * #### Notes
  //  * This will be `0` if the row headers are hidden.
  //  */
  // get headerWidth(): number {
  //   if (this._headerVisibility === 'none') {
  //     return 0;
  //   }
  //   if (this._headerVisibility === 'column') {
  //     return 0;
  //   }
  //   return this._rowHeaderSections.length;
  // }

  // /**
  //  * The virtual height of the column headers.
  //  *
  //  * #### Notes
  //  * This will be `0` if the column headers are hidden.
  //  */
  // get headerHeight(): number {
  //   if (this._headerVisibility === 'none') {
  //     return 0;
  //   }
  //   if (this._headerVisibility === 'row') {
  //     return 0;
  //   }
  //   return this._columnHeaderSections.length;
  // }

  // /**
  //  * The total virtual width of the grid.
  //  *
  //  * #### Notes
  //  * If the grid widget is sized larger than this width, a horizontal
  //  * scroll bar will not be shown.
  //  */
  // get totalWidth(): number {
  //   return this.headerWidth + this.bodyWidth;
  // }

  // /**
  //  * The total virtual height of the grid.
  //  *
  //  * #### Notes
  //  * If the grid widget is sized larger than this height, a vertical
  //  * scroll bar will not be shown.
  //  */
  // get totalHeight(): number {
  //   return this.headerHeight + this.bodyHeight;
  // }

  // /**
  //  * The width of the visible portion of the data grid.
  //  *
  //  * #### Notes
  //  * This value does not include the width of the scroll bar.
  //  */
  // get viewportWidth(): number {
  //   return this._viewportWidth;
  // }

  // /**
  //  * The height of the visible portion of the data grid.
  //  *
  //  * #### Notes
  //  * This value does not include the height of the scroll bar.
  //  */
  // get viewportHeight(): number {
  //   return this._viewportHeight;
  // }

  // /**
  //  * The width of the visible portion of the body cells.
  //  *
  //  * #### Notes
  //  * This value does not include the width of the row headers.
  //  */
  // get pageWidth(): number {
  //   return Math.max(0, this._viewportWidth - this.headerWidth);
  // }

  // /**
  //  * The height of the visible portion of the body cells.
  //  *
  //  * #### Notes
  //  * This value does not include the height of the column headers.
  //  */
  // get pageHeight(): number {
  //   return Math.max(0, this._viewportHeight - this.headerHeight);
  // }

  // /**
  //  * Get the current client rect for the data grid viewport.
  //  *
  //  * @returns The current client rect for the viewport.
  //  *
  //  * #### Notes
  //  * This rect is useful for grid behaviors when converting from
  //  * client mouse position to local viewport coordinates.
  //  */
  // viewportClientRect(): ClientRect {
  //   return this._viewport.node.getBoundingClientRect();
  // }

  // /**
  //  * Get the total number of sections in a section group.
  //  *
  //  * @param group - The section group of interest.
  //  *
  //  * @returns The total number of sections in the group.
  //  *
  //  * #### Notes
  //  * This value is equivalent to that provided by the data model.
  //  */
  // sectionCount(group: DataGrid.SectionGroup): number {
  //   return this._getSectionList(group).count;
  // }

  // /**
  //  * Get the total virtual length of a section group.
  //  *
  //  * @param group - The section group of interest.
  //  *
  //  * @returns The total virtual length of the section group.
  //  *
  //  * #### Notes
  //  * Header visibility has no effect on this value.
  //  */
  // sectionLength(group: DataGrid.SectionGroup): number {
  //   return this._getSectionList(group).length;
  // }

  // /**
  //  * Get the index of the section at an unscrolled offset.
  //  *
  //  * @param group - The name of the section group of interest.
  //  *
  //  * @param offset - The unscrolled offset of interest.
  //  *
  //  * @returns The index of the section, or `-1` if `offset` is invalid.
  //  */
  // sectionIndex(group: DataGrid.SectionGroup, offset: number): number {
  //   return this._getSectionList(group).indexOf(offset);
  // }

  // /**
  //  * Get the unscrolled offset of a section in the data grid.
  //  *
  //  * @param group - The name of the section group of interest.
  //  *
  //  * @param index - The index of the section of interest.
  //  *
  //  * @return The offset of the section, or `-1` if `index` is invalid.
  //  */
  // sectionOffset(group: DataGrid.SectionGroup, index: number): number {
  //   return this._getSectionList(group).offsetOf(index);
  // }

  // *
  //  * Get the size of a section in the data grid.
  //  *
  //  * @param group - The name of the section group of interest.
  //  *
  //  * @param index - The index of the section of interest.
  //  *
  //  * @return The size of the section, or `-1` if `index` is invalid.

  // sectionSize(group: DataGrid.SectionGroup, index: number): number {
  //   return this._getSectionList(group).sizeOf(index);
  // }

  // /**
  //  * Resize a section in the data grid.
  //  *
  //  * @param group - The name of the section group of interest.
  //  *
  //  * @param index - The index of the section of interest.
  //  *
  //  * @param size - The new size for the section.
  //  *
  //  * #### Notes
  //  * This is a no-op if `index` is invalid.
  //  */
  // resizeSection(group: DataGrid.SectionGroup, index: number, size: number): void {
  //   this._resizeSection(this._getSectionList(group), index, size);
  // }

  // /**
  //  * Get the base size of a section group.
  //  *
  //  * @param group - The section group of interest.
  //  *
  //  * @returns The base size of the specified section group.
  //  */
  // sectionBaseSize(group: DataGrid.SectionGroup): number {
  //   return this._getSectionList(group).baseSize;
  // }

  // /**
  //  * Set the base size of a section group.
  //  *
  //  * @param group - The section group of interest.
  //  */
  // setSectionBaseSize(group: DataGrid.SectionGroup, size: number): void {
  //   // Normalize the size.
  //   size = Math.max(0, Math.floor(size));

  //   // Fetch the section list.
  //   let list = this._getSectionList(group);

  //   // Bail early if the size does not change.
  //   if (list.baseSize === size) {
  //     return;
  //   }

  //   // Update the list base size.
  //   list.baseSize = size;

  //   // Sync the viewport
  //   this._syncViewport();
  // }

  /**
   * Reset sections in the data grid to their base size.
   *
   * @param group - The name of the section group of interest.
   */
  resetSections(group: DataGrid.SectionGroup): void {
    // Reset the section list to the base size.
    this._getSectionList(group).reset();

    // Sync the viewport.
    this._syncViewport();
  }

  // /**
  //  * Scroll the viewport by one page.
  //  *
  //  * @param - The desired direction of the scroll.
  //  */
  // scrollByPage(dir: DataGrid.ScrollDirection): void {
  //   let dx = 0;
  //   let dy = 0;
  //   switch (dir) {
  //   case 'up':
  //     dy = -this.pageHeight;
  //     break;
  //   case 'down':
  //     dy = this.pageHeight;
  //     break;
  //   case 'left':
  //     dx = -this.pageWidth;
  //     break;
  //   case 'right':
  //     dx = this.pageWidth;
  //     break;
  //   default:
  //     throw 'unreachable';
  //   }
  //   this.scrollBy(dx, dy);
  // }

  // /**
  //  * Scroll the viewport by one cell-aligned step.
  //  *
  //  * @param - The desired direction of the scroll.
  //  */
  // scrollByStep(dir: DataGrid.ScrollDirection): void {
  //   let r: number;
  //   let c: number;
  //   let x = this.scrollX;
  //   let y = this.scrollY;
  //   let rows = this._rowSections;
  //   let columns = this._columnSections;
  //   switch (dir) {
  //   case 'up':
  //     r = rows.indexOf(y - 1);
  //     y = r < 0 ? y : rows.offsetOf(r);
  //     break;
  //   case 'down':
  //     r = rows.indexOf(y);
  //     y = r < 0 ? y : rows.offsetOf(r) + rows.sizeOf(r);
  //     break;
  //   case 'left':
  //     c = columns.indexOf(x - 1);
  //     x = c < 0 ? x : columns.offsetOf(c);
  //     break;
  //   case 'right':
  //     c = columns.indexOf(x);
  //     x = c < 0 ? x : columns.offsetOf(c) + columns.sizeOf(c);
  //     break;
  //   default:
  //     throw 'unreachable';
  //   }
  //   this.scrollTo(x, y);
  // }

  // *
  //  * Scroll the viewport by the specified delta.
  //  *
  //  * @param dx - The scroll X delta, in pixels.
  //  *
  //  * @param dy - The scroll Y delta, in pixels.

  // scrollBy(dx: number, dy: number): void {
  //   this.scrollTo(this.scrollX + dx, this.scrollY + dy);
  // }

  /**
   * Scroll to the specified offset position.
   *
   * @param x - The scroll X offset, in pixels.
   *
   * @param y - The scroll Y offset, in pixels.
   *
   * #### Notes
   * The scroll position will be clamped to the allowable range.
   *
   * Fractional values will be rounded to the nearest integer.
   */
  scrollTo(x: number, y: number): void {
    // Floor and clamp the position to the allowable range.
    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));
    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));

    // Update the scroll bar values with the desired position.
    this._hScrollBar.value = x;
    this._vScrollBar.value = y;

    // Post a scroll request message to the viewport.
    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);
  }

  // /**
  //  * Schedule a repaint of the data grid.
  //  *
  //  * @param x - The viewport X coordinate of the dirty rect.
  //  *
  //  * @param y - The viewport Y coordinate of the dirty rect.
  //  *
  //  * @param w - The width of the dirty rect.
  //  *
  //  * @param h - The height of the dirty rect.
  //  *
  //  * #### Notes
  //  * This method is called automatically when changing the state of the
  //  * data grid. However, it may be called manually to repaint the grid
  //  * whenever external program state change necessitates an update.
  //  *
  //  * Multiple synchronous requests are collapsed into a single repaint.
  //  *
  //  * The no-argument form of this method will repaint the entire grid.
  //  */
  // repaint(): void;
  // repaint(x: number, y: number, width: number, height: number): void;
  // repaint(): void {
  //   // Parse the arguments.
  //   let x: number;
  //   let y: number;
  //   let w: number;
  //   let h: number;
  //   switch (arguments.length) {
  //   case 0:
  //     x = 0;
  //     y = 0;
  //     w = this._viewportWidth;
  //     h = this._viewportHeight;
  //     break;
  //   case 4:
  //     x = Math.floor(arguments[0]);
  //     y = Math.floor(arguments[1]);
  //     w = Math.floor(arguments[2]);
  //     h = Math.floor(arguments[3]);
  //     break;
  //   default:
  //     throw 'unreachable';
  //   }

  //   // Bail early if there is nothing to paint.
  //   if (w <= 0 || h <= 0) {
  //     return;
  //   }

  //   // Set the paint pending flag.
  //   this._paintPending = true;

  //   // Create the paint request message.
  //   let msg = new Private.PaintRequest(x, y, x + w - 1, y + h - 1);

  //   // Post the paint request to the viewport.
  //   MessageLoop.postMessage(this._viewport, msg);
  // }


  /**
   * A type alias for the data grid section groups.
   */
  export
  type SectionGroup = 'row' | 'column' | 'row-header' | 'column-header';

  /**
   * Get the section list for the specified section group.
   */
  private _getSectionList(area: DataGrid.SectionGroup): SectionList {
    let list: SectionList;
    switch (area) {
    case 'row':
      list = this._rowSections;
      break;
    case 'column':
      list = this._columnSections;
      break;
    case 'row-header':
      list = this._rowHeaderSections;
      break;
    case 'column-header':
      list = this._columnHeaderSections;
      break;
    default:
      throw 'unreachable';
    }
    return list;
  }


  /**
   * Resize a section in the given section list.
   *
   * #### Notes
   * This will update the scroll bars and repaint as needed.
   */
  private _resizeSection(list: SectionList, index: number, size: number): void {
    // Bail early if the index is out of range.
    if (index < 0 || index >= list.count) {
      return;
    }

    // Look up the old size of the section.
    let oldSize = list.sizeOf(index);

    // Normalize the new size of the section.
    let newSize = Math.max(0, Math.floor(size));

    // Bail early if the size does not change.
    if (oldSize === newSize) {
      return;
    }

    // Resize the section in the list.
    list.resize(index, newSize);

    // Get the current size of the viewport.
    let vpWidth = this._viewportWidth;
    let vpHeight = this._viewportHeight;

    // If there is nothing to paint, sync the scroll state.
    if (!this._viewport.isVisible || vpWidth === 0 || vpHeight === 0) {
      this._syncScrollState();
      return;
    }

    // If a paint is already pending, sync the viewport.
    if (this._paintPending) {
      this._syncViewport();
      return;
    }

    // Compute the size delta.
    let delta = newSize - oldSize;

    // Paint the relevant dirty regions.
    switch (list) {
    case this._rowSections:
    {
      // Look up the column header height.
      let hh = this.headerHeight;

      // Compute the viewport offset of the section.
      let offset = list.offsetOf(index) + hh - this._scrollY;

      // Bail early if there is nothing to paint.
      if (hh >= vpHeight || offset > vpHeight) {
        break;
      }

      // Update the scroll position if the section is not visible.
      if (offset + oldSize <= hh) {
        this._scrollY += delta;
        break;
      }

      // Compute the paint origin of the section.
      let pos = Math.max(hh, offset);

      // Paint from the section onward if it spans the viewport.
      if (offset + oldSize >= vpHeight || offset + newSize >= vpHeight) {
        this._paint(0, pos, vpWidth, vpHeight - pos);
        break;
      }

      // Compute the X blit dimensions.
      let sx = 0;
      let sw = vpWidth;
      let dx = 0;

      // Compute the Y blit dimensions.
      let sy: number;
      let sh: number;
      let dy: number;
      if (offset + newSize <= hh) {
        sy = hh - delta;
        sh = vpHeight - sy;
        dy = hh;
      } else {
        sy = offset + oldSize;
        sh = vpHeight - sy;
        dy = sy + delta;
      }

      // Blit the valid content to the destination.
      this._blit(this._canvas, sx, sy, sw, sh, dx, dy);

      // Repaint the section if needed.
      if (newSize > 0 && offset + newSize > hh) {
        this._paint(0, pos, vpWidth, offset + newSize - pos);
      }

      // Paint the trailing space if needed.
      if (delta < 0) {
        this._paint(0, vpHeight + delta, vpWidth, -delta);
      }

      // Done.
      break;
    }
    case this._columnSections:
    {
      // Look up the row header width.
      let hw = this.headerWidth;

      // Compute the viewport offset of the section.
      let offset = list.offsetOf(index) + hw - this._scrollX;

      // Bail early if there is nothing to paint.
      if (hw >= vpWidth || offset > vpWidth) {
        break;
      }

      // Update the scroll position if the section is not visible.
      if (offset + oldSize <= hw) {
        this._scrollX += delta;
        break;
      }

      // Compute the paint origin of the section.
      let pos = Math.max(hw, offset);

      // Paint from the section onward if it spans the viewport.
      if (offset + oldSize >= vpWidth || offset + newSize >= vpWidth) {
        this._paint(pos, 0, vpWidth - pos, vpHeight);
        break;
      }

      // Compute the Y blit dimensions.
      let sy = 0;
      let sh = vpHeight;
      let dy = 0;

      // Compute the X blit dimensions.
      let sx: number;
      let sw: number;
      let dx: number;
      if (offset + newSize <= hw) {
        sx = hw - delta;
        sw = vpWidth - sx;
        dx = hw;
      } else {
        sx = offset + oldSize;
        sw = vpWidth - sx;
        dx = sx + delta;
      }

      // Blit the valid content to the destination.
      this._blit(this._canvas, sx, sy, sw, sh, dx, dy);

      // Repaint the section if needed.
      if (newSize > 0 && offset + newSize > hw) {
        this._paint(pos, 0, offset + newSize - pos, vpHeight);
      }

      // Paint the trailing space if needed.
      if (delta < 0) {
        this._paint(vpWidth + delta, 0, -delta, vpHeight);
      }

      // Done.
      break;
    }
    case this._rowHeaderSections:
    {
      // Look up the offset of the section.
      let offset = list.offsetOf(index);

      // Bail early if the section is fully outside the viewport.
      if (offset >= vpWidth) {
        break;
      }

      // Paint the entire tail if the section spans the viewport.
      if (offset + oldSize >= vpWidth || offset + newSize >= vpWidth) {
        this._paint(offset, 0, vpWidth - offset, vpHeight);
        break;
      }

      // Compute the blit content dimensions.
      let sx = offset + oldSize;
      let sy = 0;
      let sw = vpWidth - sx;
      let sh = vpHeight;
      let dx = sx + delta;
      let dy = 0;

      // Blit the valid contents to the destination.
      this._blit(this._canvas, sx, sy, sw, sh, dx, dy);

      // Repaint the header section if needed.
      if (newSize > 0) {
        this._paint(offset, 0, newSize, vpHeight);
      }

      // Paint the trailing space if needed.
      if (delta < 0) {
        this._paint(vpWidth + delta, 0, -delta, vpHeight);
      }

      // Done
      break;
    }
    case this._columnHeaderSections:
    {
      // Look up the offset of the section.
      let offset = list.offsetOf(index);

      // Bail early if the section is fully outside the viewport.
      if (offset >= vpHeight) {
        break;
      }

      // Paint the entire tail if the section spans the viewport.
      if (offset + oldSize >= vpHeight || offset + newSize >= vpHeight) {
        this._paint(0, offset, vpWidth, vpHeight - offset);
        break;
      }

      // Compute the blit content dimensions.
      let sx = 0;
      let sy = offset + oldSize;
      let sw = vpWidth;
      let sh = vpHeight - sy;
      let dx = 0;
      let dy = sy + delta;

      // Blit the valid contents to the destination.
      this._blit(this._canvas, sx, sy, sw, sh, dx, dy);

      // Repaint the header section if needed.
      if (newSize > 0) {
        this._paint(0, offset, vpWidth, newSize);
      }

      // Paint the trailing space if needed.
      if (delta < 0) {
        this._paint(0, vpHeight + delta, vpWidth, -delta);
      }

      // Done
      break;
    }
    default:
      throw 'unreachable';
    }

    // Sync the scroll state after painting.
    this._syncScrollState();
  }
